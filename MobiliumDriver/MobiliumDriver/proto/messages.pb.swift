// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ElementNotExists {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ElementError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: OneOf_Reason? {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  var elementNotExists: ElementNotExists {
    get {
      if case .elementNotExists(let v)? = _storage._reason {return v}
      return ElementNotExists()
    }
    set {_uniqueStorage()._reason = .elementNotExists(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Reason: Equatable {
    case elementNotExists(ElementNotExists)

  #if !swift(>=4.1)
    static func ==(lhs: ElementError.OneOf_Reason, rhs: ElementError.OneOf_Reason) -> Bool {
      switch (lhs, rhs) {
      case (.elementNotExists(let l), .elementNotExists(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ElementIndicator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ElementIndicator.OneOf_Type? = nil

  var id: String {
    get {
      if case .id(let v)? = type {return v}
      return String()
    }
    set {type = .id(newValue)}
  }

  var xpath: String {
    get {
      if case .xpath(let v)? = type {return v}
      return String()
    }
    set {type = .xpath(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case id(String)
    case xpath(String)

  #if !swift(>=4.1)
    static func ==(lhs: ElementIndicator.OneOf_Type, rhs: ElementIndicator.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.id(let l), .id(let r)): return l == r
      case (.xpath(let l), .xpath(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct StartDriverRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var udid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StartDriverResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct InstallAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var udid: String = String()

  var filePath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct InstallAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UninstallAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var udid: String = String()

  var bundleID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UninstallAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LaunchAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LaunchAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TerminateAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TerminateAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TouchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Int64 = 0

  var y: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TouchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetWindowSizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetWindowSizeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Float = 0

  var height: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct IsElementVisibleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var timeout: Float {
    get {return _storage._timeout}
    set {_uniqueStorage()._timeout = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IsElementInvisibleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var timeout: Float {
    get {return _storage._timeout}
    set {_uniqueStorage()._timeout = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IsElementVisibleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var isVisible: Bool {
    get {return _storage._isVisible}
    set {_uniqueStorage()._isVisible = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IsElementInvisibleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var isInvisible: Bool {
    get {return _storage._isInvisible}
    set {_uniqueStorage()._isInvisible = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IsElementEnabledRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IsElementEnabledResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var status: OneOf_Status? {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var isEnabled: Bool {
    get {
      if case .isEnabled(let v)? = _storage._status {return v}
      return false
    }
    set {_uniqueStorage()._status = .isEnabled(newValue)}
  }

  var failure: ElementError {
    get {
      if case .failure(let v)? = _storage._status {return v}
      return ElementError()
    }
    set {_uniqueStorage()._status = .failure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Status: Equatable {
    case isEnabled(Bool)
    case failure(ElementError)

  #if !swift(>=4.1)
    static func ==(lhs: IsElementEnabledResponse.OneOf_Status, rhs: IsElementEnabledResponse.OneOf_Status) -> Bool {
      switch (lhs, rhs) {
      case (.isEnabled(let l), .isEnabled(let r)): return l == r
      case (.failure(let l), .failure(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ClickElementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ClickElementResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var status: OneOf_Status? {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var success: Bool {
    get {
      if case .success(let v)? = _storage._status {return v}
      return false
    }
    set {_uniqueStorage()._status = .success(newValue)}
  }

  var failure: ElementError {
    get {
      if case .failure(let v)? = _storage._status {return v}
      return ElementError()
    }
    set {_uniqueStorage()._status = .failure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Status: Equatable {
    case success(Bool)
    case failure(ElementError)

  #if !swift(>=4.1)
    static func ==(lhs: ClickElementResponse.OneOf_Status, rhs: ClickElementResponse.OneOf_Status) -> Bool {
      switch (lhs, rhs) {
      case (.success(let l), .success(let r)): return l == r
      case (.failure(let l), .failure(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GetValueOfElementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GetValueOfElementResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var status: OneOf_Status? {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var value: String {
    get {
      if case .value(let v)? = _storage._status {return v}
      return String()
    }
    set {_uniqueStorage()._status = .value(newValue)}
  }

  var failure: ElementError {
    get {
      if case .failure(let v)? = _storage._status {return v}
      return ElementError()
    }
    set {_uniqueStorage()._status = .failure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Status: Equatable {
    case value(String)
    case failure(ElementError)

  #if !swift(>=4.1)
    static func ==(lhs: GetValueOfElementResponse.OneOf_Status, rhs: GetValueOfElementResponse.OneOf_Status) -> Bool {
      switch (lhs, rhs) {
      case (.value(let l), .value(let r)): return l == r
      case (.failure(let l), .failure(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SetValueOfElementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var text: SetValueOfElementRequest.TextValue {
    get {
      if case .text(let v)? = _storage._value {return v}
      return SetValueOfElementRequest.TextValue()
    }
    set {_uniqueStorage()._value = .text(newValue)}
  }

  var position: Float {
    get {
      if case .position(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .position(newValue)}
  }

  var selection: Bool {
    get {
      if case .selection(let v)? = _storage._value {return v}
      return false
    }
    set {_uniqueStorage()._value = .selection(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case text(SetValueOfElementRequest.TextValue)
    case position(Float)
    case selection(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: SetValueOfElementRequest.OneOf_Value, rhs: SetValueOfElementRequest.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      case (.position(let l), .position(let r)): return l == r
      case (.selection(let l), .selection(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct TextValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String = String()

    var clears: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SetValueOfElementResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var status: OneOf_Status? {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var success: Bool {
    get {
      if case .success(let v)? = _storage._status {return v}
      return false
    }
    set {_uniqueStorage()._status = .success(newValue)}
  }

  var failure: ElementError {
    get {
      if case .failure(let v)? = _storage._status {return v}
      return ElementError()
    }
    set {_uniqueStorage()._status = .failure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Status: Equatable {
    case success(Bool)
    case failure(ElementError)

  #if !swift(>=4.1)
    static func ==(lhs: SetValueOfElementResponse.OneOf_Status, rhs: SetValueOfElementResponse.OneOf_Status) -> Bool {
      switch (lhs, rhs) {
      case (.success(let l), .success(let r)): return l == r
      case (.failure(let l), .failure(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GetElementsCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GetElementsCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementIndicator: ElementIndicator {
    get {return _storage._elementIndicator ?? ElementIndicator()}
    set {_uniqueStorage()._elementIndicator = newValue}
  }
  /// Returns true if `elementIndicator` has been explicitly set.
  var hasElementIndicator: Bool {return _storage._elementIndicator != nil}
  /// Clears the value of `elementIndicator`. Subsequent reads from it will return its default value.
  mutating func clearElementIndicator() {_uniqueStorage()._elementIndicator = nil}

  var count: Int64 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PrepareDriverRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PrepareDriverResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MobiliumMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var startDriverRequest: StartDriverRequest {
    get {
      if case .startDriverRequest(let v)? = _storage._message {return v}
      return StartDriverRequest()
    }
    set {_uniqueStorage()._message = .startDriverRequest(newValue)}
  }

  var startDriverResponse: StartDriverResponse {
    get {
      if case .startDriverResponse(let v)? = _storage._message {return v}
      return StartDriverResponse()
    }
    set {_uniqueStorage()._message = .startDriverResponse(newValue)}
  }

  var installAppRequest: InstallAppRequest {
    get {
      if case .installAppRequest(let v)? = _storage._message {return v}
      return InstallAppRequest()
    }
    set {_uniqueStorage()._message = .installAppRequest(newValue)}
  }

  var installAppResponse: InstallAppResponse {
    get {
      if case .installAppResponse(let v)? = _storage._message {return v}
      return InstallAppResponse()
    }
    set {_uniqueStorage()._message = .installAppResponse(newValue)}
  }

  var uninstallAppRequest: UninstallAppRequest {
    get {
      if case .uninstallAppRequest(let v)? = _storage._message {return v}
      return UninstallAppRequest()
    }
    set {_uniqueStorage()._message = .uninstallAppRequest(newValue)}
  }

  var uninstallAppResponse: UninstallAppResponse {
    get {
      if case .uninstallAppResponse(let v)? = _storage._message {return v}
      return UninstallAppResponse()
    }
    set {_uniqueStorage()._message = .uninstallAppResponse(newValue)}
  }

  var launchAppRequest: LaunchAppRequest {
    get {
      if case .launchAppRequest(let v)? = _storage._message {return v}
      return LaunchAppRequest()
    }
    set {_uniqueStorage()._message = .launchAppRequest(newValue)}
  }

  var launchAppResponse: LaunchAppResponse {
    get {
      if case .launchAppResponse(let v)? = _storage._message {return v}
      return LaunchAppResponse()
    }
    set {_uniqueStorage()._message = .launchAppResponse(newValue)}
  }

  var terminateAppRequest: TerminateAppRequest {
    get {
      if case .terminateAppRequest(let v)? = _storage._message {return v}
      return TerminateAppRequest()
    }
    set {_uniqueStorage()._message = .terminateAppRequest(newValue)}
  }

  var terminateAppResponse: TerminateAppResponse {
    get {
      if case .terminateAppResponse(let v)? = _storage._message {return v}
      return TerminateAppResponse()
    }
    set {_uniqueStorage()._message = .terminateAppResponse(newValue)}
  }

  var isElementVisibleRequest: IsElementVisibleRequest {
    get {
      if case .isElementVisibleRequest(let v)? = _storage._message {return v}
      return IsElementVisibleRequest()
    }
    set {_uniqueStorage()._message = .isElementVisibleRequest(newValue)}
  }

  var isElementVisibleResponse: IsElementVisibleResponse {
    get {
      if case .isElementVisibleResponse(let v)? = _storage._message {return v}
      return IsElementVisibleResponse()
    }
    set {_uniqueStorage()._message = .isElementVisibleResponse(newValue)}
  }

  var isElementInvisibleRequest: IsElementInvisibleRequest {
    get {
      if case .isElementInvisibleRequest(let v)? = _storage._message {return v}
      return IsElementInvisibleRequest()
    }
    set {_uniqueStorage()._message = .isElementInvisibleRequest(newValue)}
  }

  var isElementInvisibleResponse: IsElementInvisibleResponse {
    get {
      if case .isElementInvisibleResponse(let v)? = _storage._message {return v}
      return IsElementInvisibleResponse()
    }
    set {_uniqueStorage()._message = .isElementInvisibleResponse(newValue)}
  }

  var isElementEnabledRequest: IsElementEnabledRequest {
    get {
      if case .isElementEnabledRequest(let v)? = _storage._message {return v}
      return IsElementEnabledRequest()
    }
    set {_uniqueStorage()._message = .isElementEnabledRequest(newValue)}
  }

  var isElementEnabledResponse: IsElementEnabledResponse {
    get {
      if case .isElementEnabledResponse(let v)? = _storage._message {return v}
      return IsElementEnabledResponse()
    }
    set {_uniqueStorage()._message = .isElementEnabledResponse(newValue)}
  }

  var clickElementRequest: ClickElementRequest {
    get {
      if case .clickElementRequest(let v)? = _storage._message {return v}
      return ClickElementRequest()
    }
    set {_uniqueStorage()._message = .clickElementRequest(newValue)}
  }

  var clickElementResponse: ClickElementResponse {
    get {
      if case .clickElementResponse(let v)? = _storage._message {return v}
      return ClickElementResponse()
    }
    set {_uniqueStorage()._message = .clickElementResponse(newValue)}
  }

  var getValueOfElementRequest: GetValueOfElementRequest {
    get {
      if case .getValueOfElementRequest(let v)? = _storage._message {return v}
      return GetValueOfElementRequest()
    }
    set {_uniqueStorage()._message = .getValueOfElementRequest(newValue)}
  }

  var getValueOfElementResponse: GetValueOfElementResponse {
    get {
      if case .getValueOfElementResponse(let v)? = _storage._message {return v}
      return GetValueOfElementResponse()
    }
    set {_uniqueStorage()._message = .getValueOfElementResponse(newValue)}
  }

  var setValueOfElementRequest: SetValueOfElementRequest {
    get {
      if case .setValueOfElementRequest(let v)? = _storage._message {return v}
      return SetValueOfElementRequest()
    }
    set {_uniqueStorage()._message = .setValueOfElementRequest(newValue)}
  }

  var setValueOfElementResponse: SetValueOfElementResponse {
    get {
      if case .setValueOfElementResponse(let v)? = _storage._message {return v}
      return SetValueOfElementResponse()
    }
    set {_uniqueStorage()._message = .setValueOfElementResponse(newValue)}
  }

  var getElementsCountRequest: GetElementsCountRequest {
    get {
      if case .getElementsCountRequest(let v)? = _storage._message {return v}
      return GetElementsCountRequest()
    }
    set {_uniqueStorage()._message = .getElementsCountRequest(newValue)}
  }

  var getElementsCountResponse: GetElementsCountResponse {
    get {
      if case .getElementsCountResponse(let v)? = _storage._message {return v}
      return GetElementsCountResponse()
    }
    set {_uniqueStorage()._message = .getElementsCountResponse(newValue)}
  }

  var prepareDriverRequest: PrepareDriverRequest {
    get {
      if case .prepareDriverRequest(let v)? = _storage._message {return v}
      return PrepareDriverRequest()
    }
    set {_uniqueStorage()._message = .prepareDriverRequest(newValue)}
  }

  var prepareDriverResponse: PrepareDriverResponse {
    get {
      if case .prepareDriverResponse(let v)? = _storage._message {return v}
      return PrepareDriverResponse()
    }
    set {_uniqueStorage()._message = .prepareDriverResponse(newValue)}
  }

  var touchRequest: TouchRequest {
    get {
      if case .touchRequest(let v)? = _storage._message {return v}
      return TouchRequest()
    }
    set {_uniqueStorage()._message = .touchRequest(newValue)}
  }

  var touchResponse: TouchResponse {
    get {
      if case .touchResponse(let v)? = _storage._message {return v}
      return TouchResponse()
    }
    set {_uniqueStorage()._message = .touchResponse(newValue)}
  }

  var getWindowSizeRequest: GetWindowSizeRequest {
    get {
      if case .getWindowSizeRequest(let v)? = _storage._message {return v}
      return GetWindowSizeRequest()
    }
    set {_uniqueStorage()._message = .getWindowSizeRequest(newValue)}
  }

  var getWindowSizeResponse: GetWindowSizeResponse {
    get {
      if case .getWindowSizeResponse(let v)? = _storage._message {return v}
      return GetWindowSizeResponse()
    }
    set {_uniqueStorage()._message = .getWindowSizeResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case startDriverRequest(StartDriverRequest)
    case startDriverResponse(StartDriverResponse)
    case installAppRequest(InstallAppRequest)
    case installAppResponse(InstallAppResponse)
    case uninstallAppRequest(UninstallAppRequest)
    case uninstallAppResponse(UninstallAppResponse)
    case launchAppRequest(LaunchAppRequest)
    case launchAppResponse(LaunchAppResponse)
    case terminateAppRequest(TerminateAppRequest)
    case terminateAppResponse(TerminateAppResponse)
    case isElementVisibleRequest(IsElementVisibleRequest)
    case isElementVisibleResponse(IsElementVisibleResponse)
    case isElementInvisibleRequest(IsElementInvisibleRequest)
    case isElementInvisibleResponse(IsElementInvisibleResponse)
    case isElementEnabledRequest(IsElementEnabledRequest)
    case isElementEnabledResponse(IsElementEnabledResponse)
    case clickElementRequest(ClickElementRequest)
    case clickElementResponse(ClickElementResponse)
    case getValueOfElementRequest(GetValueOfElementRequest)
    case getValueOfElementResponse(GetValueOfElementResponse)
    case setValueOfElementRequest(SetValueOfElementRequest)
    case setValueOfElementResponse(SetValueOfElementResponse)
    case getElementsCountRequest(GetElementsCountRequest)
    case getElementsCountResponse(GetElementsCountResponse)
    case prepareDriverRequest(PrepareDriverRequest)
    case prepareDriverResponse(PrepareDriverResponse)
    case touchRequest(TouchRequest)
    case touchResponse(TouchResponse)
    case getWindowSizeRequest(GetWindowSizeRequest)
    case getWindowSizeResponse(GetWindowSizeResponse)

  #if !swift(>=4.1)
    static func ==(lhs: MobiliumMessage.OneOf_Message, rhs: MobiliumMessage.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.startDriverRequest(let l), .startDriverRequest(let r)): return l == r
      case (.startDriverResponse(let l), .startDriverResponse(let r)): return l == r
      case (.installAppRequest(let l), .installAppRequest(let r)): return l == r
      case (.installAppResponse(let l), .installAppResponse(let r)): return l == r
      case (.uninstallAppRequest(let l), .uninstallAppRequest(let r)): return l == r
      case (.uninstallAppResponse(let l), .uninstallAppResponse(let r)): return l == r
      case (.launchAppRequest(let l), .launchAppRequest(let r)): return l == r
      case (.launchAppResponse(let l), .launchAppResponse(let r)): return l == r
      case (.terminateAppRequest(let l), .terminateAppRequest(let r)): return l == r
      case (.terminateAppResponse(let l), .terminateAppResponse(let r)): return l == r
      case (.isElementVisibleRequest(let l), .isElementVisibleRequest(let r)): return l == r
      case (.isElementVisibleResponse(let l), .isElementVisibleResponse(let r)): return l == r
      case (.isElementInvisibleRequest(let l), .isElementInvisibleRequest(let r)): return l == r
      case (.isElementInvisibleResponse(let l), .isElementInvisibleResponse(let r)): return l == r
      case (.isElementEnabledRequest(let l), .isElementEnabledRequest(let r)): return l == r
      case (.isElementEnabledResponse(let l), .isElementEnabledResponse(let r)): return l == r
      case (.clickElementRequest(let l), .clickElementRequest(let r)): return l == r
      case (.clickElementResponse(let l), .clickElementResponse(let r)): return l == r
      case (.getValueOfElementRequest(let l), .getValueOfElementRequest(let r)): return l == r
      case (.getValueOfElementResponse(let l), .getValueOfElementResponse(let r)): return l == r
      case (.setValueOfElementRequest(let l), .setValueOfElementRequest(let r)): return l == r
      case (.setValueOfElementResponse(let l), .setValueOfElementResponse(let r)): return l == r
      case (.getElementsCountRequest(let l), .getElementsCountRequest(let r)): return l == r
      case (.getElementsCountResponse(let l), .getElementsCountResponse(let r)): return l == r
      case (.prepareDriverRequest(let l), .prepareDriverRequest(let r)): return l == r
      case (.prepareDriverResponse(let l), .prepareDriverResponse(let r)): return l == r
      case (.touchRequest(let l), .touchRequest(let r)): return l == r
      case (.touchResponse(let l), .touchResponse(let r)): return l == r
      case (.getWindowSizeRequest(let l), .getWindowSizeRequest(let r)): return l == r
      case (.getWindowSizeResponse(let l), .getWindowSizeResponse(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ElementNotExists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ElementNotExists"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ElementNotExists, rhs: ElementNotExists) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ElementError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ElementError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elementNotExists"),
  ]

  fileprivate class _StorageClass {
    var _reason: ElementError.OneOf_Reason?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reason = source._reason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: ElementNotExists?
          if let current = _storage._reason {
            try decoder.handleConflictingOneOf()
            if case .elementNotExists(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._reason = .elementNotExists(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .elementNotExists(let v)? = _storage._reason {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ElementError, rhs: ElementError) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reason != rhs_storage._reason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ElementIndicator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ElementIndicator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "xpath"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .id(v)}
      case 2:
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .xpath(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.type {
    case .id(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .xpath(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ElementIndicator, rhs: ElementIndicator) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StartDriverRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StartDriverRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "udid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.udid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.udid.isEmpty {
      try visitor.visitSingularStringField(value: self.udid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StartDriverRequest, rhs: StartDriverRequest) -> Bool {
    if lhs.udid != rhs.udid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StartDriverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StartDriverResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StartDriverResponse, rhs: StartDriverResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstallAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InstallAppRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "udid"),
    2: .standard(proto: "file_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.udid)
      case 2: try decoder.decodeSingularStringField(value: &self.filePath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.udid.isEmpty {
      try visitor.visitSingularStringField(value: self.udid, fieldNumber: 1)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InstallAppRequest, rhs: InstallAppRequest) -> Bool {
    if lhs.udid != rhs.udid {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstallAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InstallAppResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InstallAppResponse, rhs: InstallAppResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UninstallAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UninstallAppRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "udid"),
    2: .standard(proto: "bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.udid)
      case 2: try decoder.decodeSingularStringField(value: &self.bundleID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.udid.isEmpty {
      try visitor.visitSingularStringField(value: self.udid, fieldNumber: 1)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UninstallAppRequest, rhs: UninstallAppRequest) -> Bool {
    if lhs.udid != rhs.udid {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UninstallAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UninstallAppResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UninstallAppResponse, rhs: UninstallAppResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LaunchAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LaunchAppRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.bundleID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LaunchAppRequest, rhs: LaunchAppRequest) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LaunchAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LaunchAppResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LaunchAppResponse, rhs: LaunchAppResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TerminateAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TerminateAppRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TerminateAppRequest, rhs: TerminateAppRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TerminateAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TerminateAppResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TerminateAppResponse, rhs: TerminateAppResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TouchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TouchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.x)
      case 2: try decoder.decodeSingularInt64Field(value: &self.y)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularInt64Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularInt64Field(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TouchRequest, rhs: TouchRequest) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TouchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TouchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TouchResponse, rhs: TouchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetWindowSizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetWindowSizeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetWindowSizeRequest, rhs: GetWindowSizeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetWindowSizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetWindowSizeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.width)
      case 2: try decoder.decodeSingularFloatField(value: &self.height)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetWindowSizeResponse, rhs: GetWindowSizeResponse) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IsElementVisibleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IsElementVisibleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "index"),
    3: .same(proto: "timeout"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _index: UInt32 = 0
    var _timeout: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _index = source._index
      _timeout = source._timeout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        case 3: try decoder.decodeSingularFloatField(value: &_storage._timeout)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 2)
      }
      if _storage._timeout != 0 {
        try visitor.visitSingularFloatField(value: _storage._timeout, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IsElementVisibleRequest, rhs: IsElementVisibleRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IsElementInvisibleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IsElementInvisibleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "index"),
    3: .same(proto: "timeout"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _index: UInt32 = 0
    var _timeout: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _index = source._index
      _timeout = source._timeout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        case 3: try decoder.decodeSingularFloatField(value: &_storage._timeout)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 2)
      }
      if _storage._timeout != 0 {
        try visitor.visitSingularFloatField(value: _storage._timeout, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IsElementInvisibleRequest, rhs: IsElementInvisibleRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IsElementVisibleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IsElementVisibleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .standard(proto: "is_visible"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _isVisible: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _isVisible = source._isVisible
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._isVisible)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._isVisible != false {
        try visitor.visitSingularBoolField(value: _storage._isVisible, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IsElementVisibleResponse, rhs: IsElementVisibleResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._isVisible != rhs_storage._isVisible {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IsElementInvisibleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IsElementInvisibleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .standard(proto: "is_invisible"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _isInvisible: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _isInvisible = source._isInvisible
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._isInvisible)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._isInvisible != false {
        try visitor.visitSingularBoolField(value: _storage._isInvisible, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IsElementInvisibleResponse, rhs: IsElementInvisibleResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._isInvisible != rhs_storage._isInvisible {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IsElementEnabledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IsElementEnabledRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "index"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _index: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _index = source._index
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IsElementEnabledRequest, rhs: IsElementEnabledRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._index != rhs_storage._index {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IsElementEnabledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IsElementEnabledResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .standard(proto: "is_enabled"),
    3: .same(proto: "failure"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _status: IsElementEnabledResponse.OneOf_Status?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2:
          if _storage._status != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._status = .isEnabled(v)}
        case 3:
          var v: ElementError?
          if let current = _storage._status {
            try decoder.handleConflictingOneOf()
            if case .failure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._status = .failure(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._status {
      case .isEnabled(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      case .failure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IsElementEnabledResponse, rhs: IsElementEnabledResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClickElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClickElementRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "index"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _index: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _index = source._index
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClickElementRequest, rhs: ClickElementRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._index != rhs_storage._index {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClickElementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClickElementResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "success"),
    3: .same(proto: "failure"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _status: ClickElementResponse.OneOf_Status?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2:
          if _storage._status != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._status = .success(v)}
        case 3:
          var v: ElementError?
          if let current = _storage._status {
            try decoder.handleConflictingOneOf()
            if case .failure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._status = .failure(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._status {
      case .success(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      case .failure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClickElementResponse, rhs: ClickElementResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetValueOfElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetValueOfElementRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "index"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _index: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _index = source._index
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetValueOfElementRequest, rhs: GetValueOfElementRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._index != rhs_storage._index {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetValueOfElementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetValueOfElementResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "value"),
    3: .same(proto: "failure"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _status: GetValueOfElementResponse.OneOf_Status?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2:
          if _storage._status != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._status = .value(v)}
        case 3:
          var v: ElementError?
          if let current = _storage._status {
            try decoder.handleConflictingOneOf()
            if case .failure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._status = .failure(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._status {
      case .value(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .failure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetValueOfElementResponse, rhs: GetValueOfElementResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetValueOfElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SetValueOfElementRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "index"),
    3: .same(proto: "text"),
    4: .same(proto: "position"),
    5: .same(proto: "selection"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _index: UInt32 = 0
    var _value: SetValueOfElementRequest.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _index = source._index
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        case 3:
          var v: SetValueOfElementRequest.TextValue?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .text(v)}
        case 4:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._value = .position(v)}
        case 5:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._value = .selection(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 2)
      }
      switch _storage._value {
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .position(let v)?:
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      case .selection(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SetValueOfElementRequest, rhs: SetValueOfElementRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetValueOfElementRequest.TextValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SetValueOfElementRequest.protoMessageName + ".TextValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "clears"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.value)
      case 2: try decoder.decodeSingularBoolField(value: &self.clears)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.clears != false {
      try visitor.visitSingularBoolField(value: self.clears, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SetValueOfElementRequest.TextValue, rhs: SetValueOfElementRequest.TextValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.clears != rhs.clears {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetValueOfElementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SetValueOfElementResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "success"),
    3: .same(proto: "failure"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _status: SetValueOfElementResponse.OneOf_Status?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2:
          if _storage._status != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._status = .success(v)}
        case 3:
          var v: ElementError?
          if let current = _storage._status {
            try decoder.handleConflictingOneOf()
            if case .failure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._status = .failure(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._status {
      case .success(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      case .failure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SetValueOfElementResponse, rhs: SetValueOfElementResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetElementsCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetElementsCountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetElementsCountRequest, rhs: GetElementsCountRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetElementsCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetElementsCountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_indicator"),
    2: .same(proto: "count"),
  ]

  fileprivate class _StorageClass {
    var _elementIndicator: ElementIndicator? = nil
    var _count: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementIndicator = source._elementIndicator
      _count = source._count
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elementIndicator)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._count)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elementIndicator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._count != 0 {
        try visitor.visitSingularInt64Field(value: _storage._count, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetElementsCountResponse, rhs: GetElementsCountResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementIndicator != rhs_storage._elementIndicator {return false}
        if _storage._count != rhs_storage._count {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrepareDriverRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PrepareDriverRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PrepareDriverRequest, rhs: PrepareDriverRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrepareDriverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PrepareDriverResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PrepareDriverResponse, rhs: PrepareDriverResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MobiliumMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MobiliumMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_driver_request"),
    2: .standard(proto: "start_driver_response"),
    3: .standard(proto: "install_app_request"),
    4: .standard(proto: "install_app_response"),
    5: .standard(proto: "uninstall_app_request"),
    6: .standard(proto: "uninstall_app_response"),
    7: .standard(proto: "launch_app_request"),
    8: .standard(proto: "launch_app_response"),
    9: .standard(proto: "terminate_app_request"),
    10: .standard(proto: "terminate_app_response"),
    11: .standard(proto: "is_element_visible_request"),
    12: .standard(proto: "is_element_visible_response"),
    13: .standard(proto: "is_element_invisible_request"),
    14: .standard(proto: "is_element_invisible_response"),
    15: .standard(proto: "is_element_enabled_request"),
    16: .standard(proto: "is_element_enabled_response"),
    17: .standard(proto: "click_element_request"),
    18: .standard(proto: "click_element_response"),
    19: .standard(proto: "get_value_of_element_request"),
    20: .standard(proto: "get_value_of_element_response"),
    21: .standard(proto: "set_value_of_element_request"),
    22: .standard(proto: "set_value_of_element_response"),
    23: .standard(proto: "get_elements_count_request"),
    24: .standard(proto: "get_elements_count_response"),
    25: .standard(proto: "prepare_driver_request"),
    26: .standard(proto: "prepare_driver_response"),
    27: .standard(proto: "touch_request"),
    28: .standard(proto: "touch_response"),
    29: .standard(proto: "get_window_size_request"),
    30: .standard(proto: "get_window_size_response"),
  ]

  fileprivate class _StorageClass {
    var _message: MobiliumMessage.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: StartDriverRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .startDriverRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .startDriverRequest(v)}
        case 2:
          var v: StartDriverResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .startDriverResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .startDriverResponse(v)}
        case 3:
          var v: InstallAppRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .installAppRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .installAppRequest(v)}
        case 4:
          var v: InstallAppResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .installAppResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .installAppResponse(v)}
        case 5:
          var v: UninstallAppRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .uninstallAppRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .uninstallAppRequest(v)}
        case 6:
          var v: UninstallAppResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .uninstallAppResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .uninstallAppResponse(v)}
        case 7:
          var v: LaunchAppRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .launchAppRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .launchAppRequest(v)}
        case 8:
          var v: LaunchAppResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .launchAppResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .launchAppResponse(v)}
        case 9:
          var v: TerminateAppRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .terminateAppRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .terminateAppRequest(v)}
        case 10:
          var v: TerminateAppResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .terminateAppResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .terminateAppResponse(v)}
        case 11:
          var v: IsElementVisibleRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .isElementVisibleRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .isElementVisibleRequest(v)}
        case 12:
          var v: IsElementVisibleResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .isElementVisibleResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .isElementVisibleResponse(v)}
        case 13:
          var v: IsElementInvisibleRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .isElementInvisibleRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .isElementInvisibleRequest(v)}
        case 14:
          var v: IsElementInvisibleResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .isElementInvisibleResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .isElementInvisibleResponse(v)}
        case 15:
          var v: IsElementEnabledRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .isElementEnabledRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .isElementEnabledRequest(v)}
        case 16:
          var v: IsElementEnabledResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .isElementEnabledResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .isElementEnabledResponse(v)}
        case 17:
          var v: ClickElementRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .clickElementRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .clickElementRequest(v)}
        case 18:
          var v: ClickElementResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .clickElementResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .clickElementResponse(v)}
        case 19:
          var v: GetValueOfElementRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .getValueOfElementRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .getValueOfElementRequest(v)}
        case 20:
          var v: GetValueOfElementResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .getValueOfElementResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .getValueOfElementResponse(v)}
        case 21:
          var v: SetValueOfElementRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .setValueOfElementRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .setValueOfElementRequest(v)}
        case 22:
          var v: SetValueOfElementResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .setValueOfElementResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .setValueOfElementResponse(v)}
        case 23:
          var v: GetElementsCountRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .getElementsCountRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .getElementsCountRequest(v)}
        case 24:
          var v: GetElementsCountResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .getElementsCountResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .getElementsCountResponse(v)}
        case 25:
          var v: PrepareDriverRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .prepareDriverRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .prepareDriverRequest(v)}
        case 26:
          var v: PrepareDriverResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .prepareDriverResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .prepareDriverResponse(v)}
        case 27:
          var v: TouchRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .touchRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .touchRequest(v)}
        case 28:
          var v: TouchResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .touchResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .touchResponse(v)}
        case 29:
          var v: GetWindowSizeRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .getWindowSizeRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .getWindowSizeRequest(v)}
        case 30:
          var v: GetWindowSizeResponse?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .getWindowSizeResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .getWindowSizeResponse(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._message {
      case .startDriverRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .startDriverResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .installAppRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .installAppResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .uninstallAppRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .uninstallAppResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .launchAppRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .launchAppResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .terminateAppRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .terminateAppResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .isElementVisibleRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .isElementVisibleResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .isElementInvisibleRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .isElementInvisibleResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .isElementEnabledRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .isElementEnabledResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .clickElementRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .clickElementResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .getValueOfElementRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .getValueOfElementResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .setValueOfElementRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .setValueOfElementResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .getElementsCountRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .getElementsCountResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .prepareDriverRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .prepareDriverResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .touchRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .touchResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case .getWindowSizeRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      case .getWindowSizeResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MobiliumMessage, rhs: MobiliumMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
